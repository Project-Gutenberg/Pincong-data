---
layout: default
Lastmod: 2020-08-04T13:38:18.658211+00:00
date: 2020-08-04T13:38:18.656038+00:00
title: "游戏 2048 的基本游戏策略是什么？"
author: ""
tags: [2048,1024,512,4096,8192]
---


    
### 知乎用户 chenqin​ 发表
    
基本的思想就是递归生成

![](https://images.weserv.nl/?url=https%3A//www.zhihu.com/equation%3Ftex%3D2%255En)

，要严格按照一定步骤，就像解九连环那样，决不能碰运气。

一开始的步骤是这样，如果左下角第一个数字是

![](https://images.weserv.nl/?url=https%3A//www.zhihu.com/equation%3Ftex%3D2%255En)

，那么就在他的右边放

![](https://images.weserv.nl/?url=https%3A//www.zhihu.com/equation%3Ftex%3D2%255E%257Bn-1%257D)

，依次类推，直到剩下 4 或者 2，此时只要往末尾的数字填一个 4 或者 2，顶端数字就会变成

![](https://images.weserv.nl/?url=https%3A//www.zhihu.com/equation%3Ftex%3D2%255E%257Bn%252B1%257D)

。然后在顶端数字旁边，再用同样的方法构造

![](https://images.weserv.nl/?url=https%3A//www.zhihu.com/equation%3Ftex%3D2%255En)

，

![](https://images.weserv.nl/?url=https%3A//www.zhihu.com/equation%3Ftex%3D2%255E%257Bn-1%257D)

…… 直到逐格降幂后出现 4 或者 2。如果最后一行用完了，就转弯绕上来。  
下图是一个游戏刚开始的例子，我只要在右下角合并一个 2，顶端数字就可以变成 32，然后我继续再顶端数字旁构造 16、8……  



![](https://images.weserv.nl/?url=https%3A//pic1.zhimg.com/fc740bc3630f46ecbca107495d966cbc_r.jpg%3Fsource%3D1940ef5c)

. 严格按照这种方法，最后胜利前的图是这样的：  



![](https://images.weserv.nl/?url=https%3A//pic2.zhimg.com/80/7ff05230a1fa782255452b9957794b9d_720w.jpg%3Fsource%3D1940ef5c)

此时只要弄一个 8 出来和第三行第一列的数字合并即可达成 2048。  
这种方法要求你绝对慎用向上键。向右键也需要谨慎使用，只有在数列所在行满行的时候才能使用。否则在左下角可能会出现 4 或者 2，这会将你的数列错行。有一个问题是，这种方法做出来的 2048，由于最后一个步骤是将等比数列求和，所以屏幕上几乎不剩任何数字，分数较低。但没关系，这个小游戏刚刚取消了只能玩到 2048 的限制，只要按照这种方法玩，不仅 2048 几乎可次次达成，然后再 keep going，4096 都不是梦（需要运气）。  



![](https://images.weserv.nl/?url=https%3A//pic1.zhimg.com/cba155268b1b38100d30f1e97d0b820f_r.jpg%3Fsource%3D1940ef5c)

（败在了追寻 8192 的路上，顶部空间不够了）
    
    
    
    
### 知乎用户 耗不起的盖兹比 发表
    
重大更新！已突破 16384！求对手! 上图



![](https://images.weserv.nl/?url=https%3A//pic3.zhimg.com/3b3e84bab35d1df2c04844028f813ce2_r.jpg%3Fsource%3D1940ef5c)

实我是来显摆的。作为一个完成 8192 超 10w 分的人应该还是有资格回答这个问题的。其实按照数据帝的玩法基本是 2048 没有问题的了，还有一点就是要固定好所需要的数字，例如最后一行排列着 [256 512 1024 2048]()。这时候你就需要一个 256 在第三行第一个格，为了保持这个位置，你需要塞满第三行来固定。大概就是这样了。ps：目测极限就是 16384 了，因为我玩到 8192 的时候已经差不多没有格子放数字了，上图如此混乱是因为我已经玩到困了...=\_= 游戏的时候尽量不要向上推，推了就很难控制位置了。  
\----------------- 逼于无奈分割线 --------------- 这答案好像写得口气有点大了… 有不少人说要挑战… 但是挑战也走心一点好吗… 不要用悔棋版啊啊啊啊… 我玩的不是悔棋版啊啊啊啊… 你们用悔棋版挑战我的正常版… 我也是醉了 =\_=
    
    
    
    
### 知乎用户 RainyD 发表
    
今天下午在人人上看见这个游戏，玩了好一会儿才通关。  
首先分析下这个游戏：  
1\. 在 4 乘 4 的方格上，每移动一步会随机在空位出现 2 或 4；  
2\. 相同的数字碰撞可以合成两倍的数字；  
3\. 游戏的最终目的是合成 2048 这个数字。

鉴于每次空格里随机出现的数字是 2 和 4，所以我认为基本的策略是**将较小的数字（2,4,8…）接触到空格的概率最大化。具体来说，就是让现有的较大数字尽量在某个远离空格的角落，较小数字在更更接近空格。**

所以开局的时候我大概会比较快的无脑按 20S，将数字集中在左下角（取决于个人习惯，任一个角落没区别），如图：  



![](https://images.weserv.nl/?url=https%3A//pic2.zhimg.com/80/5b777b44ceb4b172d489a88118795b0b_720w.jpg%3Fsource%3D1940ef5c)

  
然后就开始稍微慢些观察着移动，基本原则如上所说，让新的数字尽量接触小的数字。

在移动的过程中也要注意一些细节。

比如在横向移动时记得保证最下一排是满的（有四个数字），这是为了防止随机数出现在最下面一排。

最后就是这样啦：



![](https://images.weserv.nl/?url=https%3A//pic2.zhimg.com/80/97403932b549ffca6826a9d114e5c8f0_720w.jpg%3Fsource%3D1940ef5c)

PS：貌似在完成 2048 的同时分数越高越好，有志之士们继续努力吧~~

知乎首答，后续想到啥再补充。
    
    
    
    
### 知乎用户 陆家贤  发表
    
[2048 超进化 - U77 总有好游戏](https://link.zhihu.com/?target=http%3A//www.u77.com/game/1226)  
我觉得各位应该好好的来这里体验下如何快速达到 2048！！！  



![](https://images.weserv.nl/?url=https%3A//pic2.zhimg.com/0abe38677ef5985be10b8544864be3b1_r.jpg%3Fsource%3D1940ef5c)
    
    
    
    
### 知乎用户 ccccw 发表
    
首先分析 2048 游戏:  
**1\. 格子里的总数字会随着步数增加而以 2 或 4 地增加。**所以，要达到 2048，必须有足够多的步数作为支撑。即玩家坚持的步数越多，胜利希望也越大。  
**2\. 四个方向地位相等。**  
**3\. 要持续游戏，需要方格之间的 “密度”(即数字大小) 相对一致。**这样才能使得合并变得可能。  
**4\. 游戏系统选择一个空格随机出现 2 或 4。**所以当任何一个方块被移动时，它原来的位置都有一定概率出现新的数字，从而可能打乱玩家的安排。

  

基于以上分析，可以得到下面的想法:  
**1\. 使得方格之间的 “密度” 趋于一致。**由于有一个最大的目标 (即 2048)，在完成这个目标前，这个方格的数值是相当大的。为了使得方格之间“密度” 趋于一致，我们需要尽量减少与之交接的格子数量。所以，**一个最大的数只能放在角上**。既然只能放在角上，那么就注定它不能移动 (见分析 4)。类似的，次大的数(如 1024 512 之流) 只能放在最大数的直接邻域，且顺序固定或无大变化 (如最底一行是 2048 1024 512 256)。同时，由于角点处有两个方向(如左下角，有最左边和最下边两个方向)，而达到目的只需要一个方向的排列就够了，所以我们可以舍弃一个方向(如舍弃最左边，即保留最底一行的排列是 2048 1024 512 256，则“up” 的操作被舍弃，否则会使得左下角最大数发生可能的位置变化，即我们只用三个方向完成游戏。只要控制好，可以保证不出现非 up 不可的情况，下面都基于舍弃 up 来实现)。同时，为了生成和将最大数压在左下角，left 和 down 优先级相对比 right 高。

2\. 为了实现想法 1，在达到目标前，我们需要保持这样的排列而无变化 (注意，是无变化。**即无论怎样操作最底一行的排列永远是类似 2048 1024 512 256 这样的大小顺序)，我们需要保证左右移动时最下一行的排列不变，同时也是整个 4 乘 4 矩阵中最大的一排。**所以，在选择 left 还是 down 的时候，当最下一排没有被填满时，用 down。填满后视用 left 将最下一排合并，出空格后继续 down，直到用 left 对最后一排压不出来空格。此时 left 和 right 随便用，但是要控制好不出现非 up 的情况。  
**3\. 不断重复以上过程。**同时注意不断提高最下一排的密度。注意微调防止死。达到目标只是时间和耐心的问题。

  

总而言之，开局胡乱 down+left，稳定后微调使得最下一排按序排列成等比数列，再按思路走就行了。一般 2048 用 8 分钟，斐波那契慢一点但也在 15 分钟内吧。完全无脑直接按，只有濒死状态才微调，很快又能出无脑按。

  

本方法不仅对 4 乘 4 传统 2048 有效，还对 8 乘 8 的 65536 以及 4 乘 4 的斐波那契也有效。因为我的分析与具体消数规则无关，也与尺寸无关。算法验证还在用 matlab 写，但估计没那么快做出来，时间有限，关键还是码力太差了◑▂◐。

  

本答案纯粹抛砖。

\=====================2014.6.22 更新 =============================

本方法有缺陷。

  

在写代码到一半时，我发现步骤 2 中的黑体字有的时候是不能实现的。还有，有的时候会非用 up 不可，从而被打乱计划。多次实验后发现这貌似是不可用操作避免的。  

  

更多的讨论，请看：[What is the optimal algorithm for the game, 2048?](https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/22342854/what-is-the-optimal-algorithm-for-the-game-2048)
    
    
    
    
### 知乎用户  王志刚 发表
    


![](https://images.weserv.nl/?url=https%3A//pic2.zhimg.com/e1a79c125ee723f12ae196ae1a01d6b2_r.jpg%3Fsource%3D1940ef5c)

  

游戏介绍：

　　“2048”，在一个 4\*4 的方格中进行。通过方向键操作，在同一直线上，沿移动方向，数字相同合并（加法）。3 个相同数字，则按先后合并。既，4，4，4 向右合并，则 8，4；向左，则 8，4。向上向下同理。每次方向操作后，都会在没有数字的空格位置产生一个数字（一般只会出现 2,4，没看源码）。产生数 2048，则挑战成功。16 个方格都有数字且无法再合并，则挑战失败。

[核弹\_百度百科](https://link.zhihu.com/?target=http%3A//baike.baidu.com/view/27804.htm)

核心：

　　2 + (2 + 4 + 8 + 16) = 32

　　.

　　.

　　.

　　128+(128 + 256 + 512 + 1024)= 2048

S 型进贡”。

优点：操作步数少，方便快捷。15 分钟就可以闯过 “16 铜人阵”。

思路：

把方格分成 2 类，积累区（第一行，颜色阶梯）和拼凑区（第二三四行）。

积累区：

  

放置大树，且 a\[1\]\[4\] 最大，a\[1\]\[3\] 次之，a\[1\]\[2\] 再次, a\[1\]\[1\] 最小。

如果局点：a\[1\]\[4\]=1024,a\[1\]\[3\]=512,a\[1\]\[2\]=256,a\[1\]\[1\]=128,a\[2\]\[1\]=128，那么只要上右右右右合并就形成 2048。由此，只要一开始就在积累区形成阶梯安排，那么依次累加就会形成局点。因此，在积累区主要或者只需进行 “向右” 操作。形成由右向左的阶梯安排。那么如何有效的安排积累区呢？这就需要拼凑区的帮助了。

  

拼凑区：

  

既然积累区只需进行向右操作，那么如何 “进贡”？显然，a\[2\]\[1\]（蓝色）就是入口点。只要 a\[2\]\[1\]==a\[1\]\[1\]，那么就可以开始链式反应了。那么在积累区也需要类似的阶梯安排，只不过是从左向右从下向上（斜的阶梯状）。

  

操作时注意几点：

1\. 积累区不到万不得已不要 “左移”。因为左移时，可能会在 a\[1\]\[4\] 产生空格。如果没有在这个空格上产生数字，则无伤大雅；如果产生了数字，尤其是在后期，只能说你中奖了，一般都很难进行下去，不过不是绝对的，只是新的 “积累区” 就变小了。如果在积累区，由于合并产生空格，一定利用操作，将新产生的数字填满，尽量形成阶梯安排。

2\. 注意相邻合并性

(1) 由于游戏规则，相邻的数是成倍数关系 (2 倍, 4 倍, 8 倍...)。相邻的数相差不要太大，保持在 2 倍，4 倍为妙。

(2)既然入口点 a\[2\]\[1\], 那么它的 “进贡点”a\[2\]\[2\] 和 a\[3\]\[1\]就尤其重要。如果 a\[2\]\[2\]>a\[2\]\[1\]，那么只能由 a\[3\]\[1\]来 “进贡”；同理，如果 a\[3\]\[1\]>a\[2\]\[1\]，那么只能由 a\[2\]\[2\] 来“进贡”。剩下的格子作为“再次进贡点”，同时注意(1)。

3\. 即使在挑战过程中，产生了 “要悲剧点”，耐心发现联系，调整过来。只要能形成阶梯安排，“上上下下左左右右” 的直上直下操作也无妨，要灵活多变，因地制宜。

4\. 最后，“实践出真知，熟能生巧”。

以上只是个人的一些看法，欢迎来电来信来连探讨。
    
    
    
    
### 知乎用户 BookerDewitt 发表
    


![](https://images.weserv.nl/?url=https%3A//pic3.zhimg.com/80/v2-f93936d5f04bcd29471e1003d60cf3fc_720w.jpg%3Fsource%3D1940ef5c)

（右上角本可是个 2，平凡的 2）

我来写一个攻略，帮助各路玩家理顺玩 2048 的思路。我不准备开口就宣讲怎么才能达到我那么高的水平，那样太轻松、幼稚和不劳而获了。相反，我要以导师的态度向你们传授怎么才能在这款小游戏里走得更远——这并不比练出八块腹肌简单，但也不加难。要知道，咬住痛苦的乳房甘之如饴，人人都能吸出甜美的奶水来。

\--------------------

第一章：新手入门

最初的最初，一眼看去方向尚无意义，天高海阔任君去，左右逢源空格多。

（配一张只有两个 2 的图）

犹犹豫豫开始循着游戏的指引无意识四向瞎滚，随便滚个 70-120 步后，第一个三位数跃然屏上。

（一个中间有 128 的图）

再做数百动作，却惊觉已被杂多束住手脚。

（一个 512 + 乱七八糟数字的图）

（大的巨物被小的喽啰蚕食，不得相见；小的鱼虾被大的顽石分隔，无法聚集）

挣扎、扭动、没落。

（一张 you died）

（资本的原始积累失败了，游戏在封建末潮的割据混战中落幕 / 玩一个三体游戏梗）

\--------------------

第二章：走出丛林，迎接秩序

又一次站在最初的最初，作为玩家的你却能带着上一轮的惨烈记忆——这是游戏人的幸运。

（一个只有两个 2 的开局，位置明显不同于图 1，最好是贴边缘的并排）

这一次，我们引入简单规则，最大数高踞一角，小数不断向其靠拢。

（一个角落有 512 的图）

但是，意料之外的情况总是会出现的。（注 1）（见文末附录：方法论）

（一个左下角是 2，1024 在它上面的图）

这意味着简单规则仍有十分不足，其组织太过松散无力。对于这一点需要加以限制。

（一张左下角上数 1024、512、256 的图）

同样需要注意的是，这种方法的运用十分普遍。最大数列、次大数列乃至有限空间都可以使用。可以避免下图情况出现。（注 2） （见文末附录：方法论）

（一张第二列上数 2、64、等）

来到游戏的一道门槛前，跨过去、跨过去！

（一张 1024、512、256、128、128）

欢迎来到旅途的终点站，请轻度玩家落车并截图留念。

（一张 2048）

（一张你赢了 2048）

\--------------------

第三章：游戏开始

点击继续游戏，思考前路迢迢何以致千里。

（一张左下 2048、256 等）

大方向既定，且行且审慎。

（一张 2048、512 等）

似曾相识的一幕出现了，玩家隐隐预见到前路的康庄大道将化为羊肠小径，每一步都如踏在荆棘丛中。

（一张 2048、512、256、128、128）

为什么又一次在余三列的空间里造出 128？这和达到 2048 的道路如出一辙。

（一张 2048、1024、256、128、128）

规则似乎浮出水面，但被水上的雾气盖住了真正的面容。

（一张 2048、1024、512、128、128）

这是一则铁律：以这种学院派的方式游戏，必须千百次踏过同一条、也是最初的门槛：角落里的 128 与 128。然后，一个更高、更大者来到你面前。

（一张 2、1、0.5、0.25、0.25）

显然，这是上升到下一个平台所必经的考验——更严苛、更残酷的门槛。你同时也意识到，这不会是你最后一次踏上这道门槛。

（一张 4096）

（一张 4096 胜利）

\--------------------

第四章：基础世界观

由于一些误操作，你死了

（一张 you died）

（一张 4096、1024、256）

仍然循着前述方针走在正确的道路上——但你还是死了，这显然能说明一些问题：方法正确，这游戏就能一直玩下去么？

（两张 4096 死、一张 2048 死）

（三张 you died）

也许是方法的错？其他探索的路上 you died\*100

也许是操作的问题？哪怕步步为营算得一清二楚，you died\*100

这是个运气游戏，不过如此而已！

但是有人能玩出 16384 并且觊觎 32768 的宝座（比如我），有人只能玩个 4096 就沾沾自喜（比如你，甚至达不到，真菜！）

一定有什么方法可以走得更远？

（一张 8192）

（一张 8192 胜利）

那就是不要死。

只要不死，这个游戏可以玩到的理论极限是 131072+65536+32768+16384+8192+4096+2048+1024+512+256+128+64+32+16+8+4

这意味着要每一次产生新数字时都产生 4，这是不可控的。

那么，小一级的理论极限是可能的吗？一个 65536+32768+16384+8192+4096+2048+1024+512+256+128+64+32+16+8+4+2？

为了说明这个理论极限事实上有多么反人类，我们回到 4096 的级别上来进行阐述。

（一张 4096 胜利）

在这段苦难的记忆中，为了达到 4096 胜利，必须 4 次踏上 2048 的门槛。

第一次，是来到 2048。

第二次，是在 2048 的次位造出 1024。

第三次，是在 1024 的次位造出 512。

第四次，是在 512 的次位造出 256。

这四次门槛的相同点，在于：除大数列外，余三列的最大位上诞生一个 128。

（四张图，分别是上述四种情况的 128）

我们将其称为一级门槛，因为这不是唯一的门槛。更高、更大者是你必须克服，而不能是将你克服的障碍。

你必须在余三列的角落诞生一个 256。跨国一个二级门槛。

（一张 2、1、0.5、0.25、0.25）

聪明的你，完全可以想象到为了达到 8192，这个游戏的难度会发生怎样的变化。

首先，在左下角 4096 的基础上，于次位产生一个 1024，一个一级门槛。

（4+0.5+0.25+0.1+0.1）

（4+1）

同理，第三顺位的 512 和第四顺位的 256 的生产都需要通过一级门槛。

接下来你发现，为了在左下角 4096 的基础上，于次位产生一个 2048，必须通过二级门槛。

（4+1+0.5+0.25+0.25）

（4+2）

继续推导，第三顺位的 1024 和第四顺位的 512 的生产都需要通过二级门槛。

并且，这个过程中还需要走过三次一级门槛。

最后，终于，好不容易，你踏上第三级门槛，来到 8192 平台。

（8192）

（8192 胜利）

欢迎你，堪堪脱离 90% 的玩家，值得庆贺。

现在我们携手展望一下未来，看看上到下一个 16384 平台上需要付出一番怎样的努力。



![](https://images.weserv.nl/?url=https%3A//pic1.zhimg.com/80/v2-f11ac05bada29458cd252cb3ac327319_720w.jpg%3Fsource%3D1940ef5c)

如果从初生玩起，共计需要 20 个一级（2048 级）、10 个二级（4096 级）、4 个三级（8192 级）和 1 个四级（抵达 16384）。

再多看一步，如果想走到 32768，需要 35 个一级、20 个二级、10 个三级、4 个四级和 1 个五级（抵达 32768）。

这意味着，如果没有稳定达到 4096 的水平，需要 4 个二级才能玩出的 8192 对你来说希望渺茫。更不须谈 10 个二级、4 个三级和 1 个四级才能玩出的 16384 和天一样远的 32768 了。

假定你有 50% 的把握玩出 4096（二级门槛），那么即便不考虑诸多一级门槛和最终的三级门槛，达到 8192 的概率也仅仅为 (50%)^4=6.25%，这就是这个游戏的惊人之处：每上一个平台，就要面对累加的门槛数，以及它们自相乘带来的微暗概率。

\--------------------

第五章：微暗的火

没有被吓退的你（假定这些你存在）玩得吐血，抵达 16384，你成为了我的战友。这在外人看来多少有点怪异，因为这似乎不是一款值得玩得吐血的游戏。

（一张 16384，你的新目标是 32768）

（一张 16384 胜利）

直到这时，我才有机会把人力能及的终极目标指给你看，因为你站的平台足够高、也就能看得足够远了。

那个目标就是 32768。在最远端，火光微暗。

走到这么远，早已压住心底的恐惧，觉得自己无所不能了吧？还记得提到过的小一级理论极限吗？一个 65536+32768+16384+8192+4096+2048+1024+512+256+128+64+32+16+8+4+2 才是最高峰的腊梅，最远极的安息处。区区 32768 算什么呢？

32768 就是人的极限，我对此不存任何困惑。论证如下：

在先前的游戏中，我们关注的门槛是大数列外余三列空间内生产的最大数——造出 128 就能踏上 2048，为一级门槛；造出 256 就能踏上 4096，为二级门槛；以此类推，只要能在这个位置造出 2048（多么有趣的原点），就能推回 4096、8192、16384，最终踏上 32768。这是末一级门槛，序列为五。

在游戏的进程里，你不免发现，99% 的时间不会涉及到跨过门槛。这些时间里你都在和余三列奋斗，力图抵达门槛的边缘。

（一张 2048、一张 4096、一张 8192 任意门槛）

而在余三列的时间中，又有半数是在余二列中不断腾挪，用灵活的技巧博升阶。

（一张 8+4 的余二列，一张 8+4+2+1 的余二列）

甚至在死亡与死亡之间，你都在对闭塞的余二列空间感到恐惧。

（8+4+2+1 余二列阵亡）

（you died）

但是每一次成功来到新平台前，都是滚雪球般的柳暗花明又一村。

（一张 8+4+2+1+0.5+0.25……）

因此，终点不在五级门槛，而在余二列的狭小空间里。

要问的问题是这样的：在余二列里，我有把握造出最大的数是多少？

（余二列的 128）

答案是 128，当初绞尽脑汁爬到 2048 上的垫脚石又一次出现在这里。不同的是，现在只需要 2\*4=8 个格子就能造出来。

让我们首先把视野聚焦到余二列的 2\*4 方格中。

（空的 2\*4 方格截图）

一个 128 意味着两个 64，一个在角落的 64 和一个贪吃蛇的 64。它的过程当然会是 64+32+16+8，于是余二列也被锁死了，现在终极使命是在余一列中的端头处产生一个 8。

（64+32+16+8 和单列一个 8）

这就是终极目标的基石，单列造 8。在它之上的单列造 16 和单列造 32 分别对应着六级和七级门槛。这两个技巧往简单说——前者几乎做不到，后者几乎不可能。（注 4）

着眼于单列造 8 问题。

当前三列锁死，最后一列的上和下就成了解决这个问题的唯一操作方式。

第一步：一个 2 移动后会变成两个 2 共存，与天然的两个 2 没有任何区别。

（配两个 2 的图）

第二步：若要在上方造 8，务必将两个 2 向下移动，合并为 4，理由很明朗——向上你有 1/6 概率会暴死，向下则不必面对这一悲惨结局。

（4 在底，上贴 2）

不能向下动了！只能向上……

（2 在顶，贴着 4，贴着 2）

又不能向上了！只能向下……

（从上到下 2242）

向中间合并出 8 无异于自寻死路，向上合并出 8 则顺利达成目标。但无论如何都不可能在下端造出 8 来。反之，若第一个 4 向上移动，有 1/6 的概率陷入无法在上端造出 8 的局面。

（端头的 8）

当你达到我的水平，2048 只要 5 分钟不到、8192 信手拈来、16384 一小时一个的时候，就有能力向 32768 发起冲锋，避开诸多陷阱（见附录：方法论部分），把手伸向顶端的果实。

独独不能考虑刷出 4 的情况，是命，不可违。

  



![](https://images.weserv.nl/?url=https%3A//pic2.zhimg.com/80/v2-f93936d5f04bcd29471e1003d60cf3fc_720w.jpg%3Fsource%3D1940ef5c)

  

（you died）

祝你好运！

\--------------------

附录：解决局部难题的方法论

注 1：最大位松动的解决方案

注 2：余三列最大位松动的解决方案

注 3：大数列整体移动的解决方案

注 4：单列造 16 和单列造 32 的不可行性演示

注 5：余三列造数小技巧

注 6：余二列造数小技巧

注 7：一个奇淫巧技

\--------------------

后记：

引文以明志

夫夷以近，则游者众；险以远，则至者少。而世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。有志矣，不随以止也，然力不足者，亦不能至也。有志与力，而又不随以怠，至于幽暗昏惑而无物以相之，亦不能至也。然力足以至焉，于人为可讥，而在己为有悔；尽吾志也而不能至者，可以无悔矣，其孰能讥之乎？此余之所得也！

为这篇答案创造了诸多生捏硬造的概念，希望读者结合游戏元素自行理解。不另附专业名次表加以一一说明，以免凸显学院派作风降低可读性。

特别鸣谢天底下最可爱的包仔的热情督促，使我聚集起来作文动力，不至于流产难产而死，终于写成。给你肚肚！
    
    
    
    
### 知乎用户 ThatMercy 发表
    
想用算法来解决问题：  
所以，只做知识的搬运工 (图好像不稳定)：  
[What is the optimal algorithm for the game 2048?](https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/22342854/what-is-the-optimal-algorithm-for-the-game-2048)

I'm the author of the AI program that others have mentioned in this thread. You can view the AI in [action](https://link.zhihu.com/?target=http%3A//ov3y.github.io/2048-AI/) or read the [source](https://link.zhihu.com/?target=https%3A//github.com/ov3y/2048-AI).

Currently, the program achieves about a 90% win rate running in javascript in the browser on my laptop given about 100 milliseconds of thinking time per move, so while not perfect (yet!) it performs pretty well.

Since the game is a discrete state space, perfect information, turn-based game like chess and checkers, I used the same methods that have been proven to work on those games, namely [minimax](https://link.zhihu.com/?target=http%3A//www.flyingmachinestudios.com/programming/minimax/)[search](https://link.zhihu.com/?target=http%3A//xkcd.com/832/) with [alpha-beta pruning](https://link.zhihu.com/?target=http%3A//cs.ucla.edu/%257Erosen/161/notes/alphabeta.html). Since there is already a lot of info on that algorithm out there, I'll just talk about the two main heuristics that I use in the [static evaluation function](https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Evaluation_function) and which formalize many of the intuitions that other people have expressed here.

**Monotonicity**

This heuristic tries to ensure that the values of the tiles are all either increasing or decreasing along both the left/right and up/down directions. This heuristic alone captures the intuition that many others have mentioned, that higher valued tiles should be clustered in a corner. It will typically prevent smaller valued tiles from getting orphaned and will keep the board very organized, with smaller tiles cascading in and filling up into the larger tiles.

Here's a screenshot of a perfectly monotonic grid. I obtained this by running the algorithm with the eval function set to disregard the other heuristics and only consider monotonicity.



![](https://images.weserv.nl/?url=https%3A//pic4.zhimg.com/80/ad01c994e66faeddf4911b984624d5b8_720w.jpg%3Fsource%3D1940ef5c)

  
**Smoothness**

The above heuristic alone tends to create structures in which adjacent tiles are decreasing in value, but of course in order to merge, adjacent tiles need to be the same value. Therefore, the smoothness heuristic just measures the value difference between neighboring tiles, trying to minimize this count.

A commenter on Hacker News gave [an interesting formalization](https://link.zhihu.com/?target=https%3A//news.ycombinator.com/item%3Fid%3D7381082) of this idea in terms of graph theory.

Here's a screenshot of a perfectly smooth grid, courtesy of [this excellent parody fork](https://link.zhihu.com/?target=http%3A//jennypeng.me/2048/).



![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='342' height='343'></svg>)

  
**Free Tiles**

And finally, there is a penalty for having too few free tiles, since options can quickly run out when the game board gets too cramped.

And that's it! Searching through the game space while optimizing these criteria yields remarkably good performance. One advantage to using a generalized approach like this rather than an explicitly coded move strategy is that the algorithm can often find interesting and unexpected solutions. If you watch it run, it will often make surprising but effective moves, like suddenly switching which wall or corner it's building up against.

_Edit:_

Here's a demonstration of the power of this approach. I uncapped the tile values (so it kept going after reaching 2048) and here is the best result after eight trials.



![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='345' height='499'></svg>)

  

Yes, that's a 4096 alongside a 2048. =) That means it achieved the elusive 2048 tile three times on the same board.
    
    
    
    
### 知乎用户 Icy 在改变 发表
    
5.9update，一点小修改。

个人测试合成 2048 需要 7 分钟，4096 需要 15 分钟左右，珍爱生命，远离 2048 :)

  

已经玩了很久，已合成 8192，基本每局都能合成 4096 的来挖个坑，早晨起来就答～

不过我的水准暂时也就是 8192，大神们就不要搭理我了，新手们可以看一下嗯。

个人认为这个游戏是比较机械的，有固定的玩法，只要不出差错，2048 还是很容易得到的~



![](https://images.weserv.nl/?url=https%3A//picb.zhimg.com/fd0a370f7a37aa1575d3dc588a6b4259_r.jpg%3Fsource%3D1940ef5c)

  
第一次觉得有一个问题一定要认真答一下！！毕竟花费了数十小时玩这个！

下面就是我的一点见解。 ：）

  
我认为这个游戏可以分为几个阶段。  

**1\. 初期（刚开始一局游戏）**

**有序性（水准至少是对这游戏已经有所了解）**

  

这个游戏很关键的就是数字的布局要有序。

对于我的游戏习惯而言，就是**最大的数字**摆在左上角，且**尽量不让它移动，**左边数第一列的数字，大小顺序就如上图那样，最大的在左上，然后从大到小排布下来。

这样做的意义在于所有的数周围都是大小接近的数字，方便合成更大的数字， 初期的布局就如下图。



![](https://images.weserv.nl/?url=https%3A//pic4.zhimg.com/6fe728004c293482f9881eb42e9796fc_r.jpg%3Fsource%3D1940ef5c)

按照这种布局， 很关键的就是你**一定不能向右**或者向下划（第一列四个数字都不相同的时候是可以向下的，如上图，因为第一列没有相同的数字，向下划时，只会移动另外三列，而第一列不会向下），如果你向右划，则很可能出现一个 2 在第一列，因为周围的数字都比较大，所以难以合成新的数字，会造成很大的麻烦，新手很可能就玩死了（**当然还是可以拯救的，后面提到**）。  

**2\. 中期**

**合成 512 1024 之后**

在合成 1024 之后，你会发现你的格子有点不够用了！如下图~



![](https://images.weserv.nl/?url=https%3A//picb.zhimg.com/953de1aa33ceca5ae225f008e3170b6f_r.jpg%3Fsource%3D1940ef5c)

此时就要用到第二列了，具体的方法是**第一列从大到小**排布下来，**第二列从小到大**排布下来，同时让第一列最小的数字和第二列最大的数字大小接近。

目的是让第二列最大的数及时与第一列最小的数合成新的数字，从而节省格子。布局如同上图~

  

但是很有可能你的布局出现我这样的问题（如上图），第二列最大的数字大于第一列最小的数。此时就会导致第二列最大的数字不方便加入第一列。

此时的解决方法有两种：

1\. 把 64 移到上面的位置，然后移动一个 2 到 64 和 32 所夹的格子处，再然后把这个数字不断合成为更大的数字，到了 32 时就可以让它加入第一列了！然后继续保持这种布局继续完成~

2\. 可以将错就错，将第二列最大的数字合成到和第一列倒数第二位的数字相同时再加入第一列，比如上图中的 64 可以进一步做成 128 再与第一列的 128 合成更大的数字。

  

**3\. 中后期**

**2048 之后的玩法（各种小问题及解决）**

其实和 1024 之后的玩法接近，就是要保证布局的稳定性，即第一列和第二列的大小顺序。

我觉得这个阶段最重要的是**细节。**

每一次向下划的时候都要注意第一列是不是又相同的数字，避免最大的数上面出现一个 2.

再比如合成过程中一定要注意出现下图的问题



![](https://images.weserv.nl/?url=https%3A//pic1.zhimg.com/032cab63eb354f8a1ca416ef1aa945d3_r.jpg%3Fsource%3D1940ef5c)

  
此时只能向右划了有木有！一划就要出问题有木有！

避免这个问题的核心我觉着就是一定要每一步都思路清晰，要让每个数字附近都是大小接近的数字，当布局不太正常的时候，早早注意到就可以避免，这样就很难出现这种问题了。

  

万一（其实根本不是万一），最大的数字上出现了一个 2，该怎么拯救！



![](https://images.weserv.nl/?url=https%3A//pic1.zhimg.com/b0254df5c0777c5a64d67bee718c5c44_r.jpg%3Fsource%3D1940ef5c)

  

具体来说就是尽量使用向下和向左的操作， **将 1024 这一行的四个数字做成不一样的（确保不会向右移动），且 1024 上 的那一行可以向右滑动，**此时向右划，空出 1024 上的位置，向上滑就把 1024 移动到了左上角，再然后就是调整一下布局，使它有规律，就可以继续操作了。  

  

第二种方法还是将错就错，将上图中的 2 合成一个 8，从而使第一列的数字可以向下再合成一次，这样 1024 就会出现在第三行，进行上面的操作时会更容易调整。

  

**4\. 后期**

**4096 以后**

个人认为此时的难度主要是格子实在是太不够用了，第一列会塞满很大的数，所以主要依靠第二列，用之前的方法不断往第一列凑较大的数字，同时操作的时候要更加细心，避免出现只能向右划的状况，**核心的是第二列也要像第一列一样保持大小布局的稳定性（从下到上的次序为大到小），始终保证最大的在下方，且每次向上划的时候保证这一列不会动。**

  

玩到 4096 以后就很容易玩死了，所以我也就合成了两次 8192，先就想到这么多~ 如果有需要会再补充嗯，希望有人看到我的答案：）
    
    
    
    
### 知乎用户 巨根 发表
    
无意间刷到这个问题，没有别的意思，纯粹的想装一逼。  



![](https://images.weserv.nl/?url=https%3A//pic1.zhimg.com/7fa165aba06a491e33495c7c0fe518a7_r.jpg%3Fsource%3D1940ef5c)

  
这是去年 8 月份弄的，快一年没玩了。  
还有，对于二楼回答对不起了。  
唉，无敌是多么的寂寞～\[欠操\]
    
    
    
    
### 知乎用户  林茜茜 发表
    
我摸索到的 2048 通关方法：  
1\. 先贴边构建一个按幂指数增长的数列 A，比如 2,4,8,16。这样其他的 3\*4 个格子里的数字基本可以自由移动了。  
2\. 然后贴着 A 构建一个幂指数小一级的数列 B, 比如：空，2,4,8。然后推两下就可以和旁边列 A 消除，得到 32 了。  
3\. 始终保持这个数列的四个数字都固定在某行，然后移动其他数字，至少最大数要在某一角。  
4\. 如此往复若干次，直到构建出最大数 1024. 这时 1024 应该在某一角。  
5\. 继续构建数列 A，即 1024,512,256,128.  
6\. 继续 S 形构建数列 C，即 64,32,16,8  
7\. 然后沿着 S 形逐个消除，就可以享受胜利的喜悦了！  
（请叫我天才少女好嘛谢谢）
    
    
    
    
### 知乎用户 郭阳 发表
    


![](https://images.weserv.nl/?url=https%3A//pic4.zhimg.com/82f4fee0d847e3e5e42fb35357198776_r.jpg%3Fsource%3D1940ef5c)

采用无耻的悔棋大法后，终于过百万了。  
玩法基本按目前的排列顺序  
\--------------------------------------------------------------------  
最终结果，理论上的最高分，累死我了  



![](https://images.weserv.nl/?url=https%3A//pic3.zhimg.com/601b4de2e291cde0b81be0bbe20d814f_r.jpg%3Fsource%3D1940ef5c)
    
    
    
    
### 知乎用户  丛广乐 发表
    
玩到 8196（2 的 13 次方）的飘过，16 个格子理论上是应该可以到 2 得 17 次方（131072，因为每次移动的新增可能是 4 相当于最后拓展了一个格子，所以是 2 的 17 次方），但我个人感觉无论再怎么斟酌技巧 2 的 14 次方也就是极限了，因为此游戏每次滑动新生出来 2 的位置是随机的。

\==== 分割线，开始回答 ====

其实得分最高的人的回答已经很好了，我随手写一下达到 2 的 16 次方的情况  
(32768) (16384) (8192) (4096)  
(256) (516) (1024) (2048)  
(128) (64) (32) (16)  
(2) (2) (4) (8)  
其实就是蛇形的，保持大小顺序，尽量做到上图所示。

\==== 我是下技巧 ====  
**一个别人没有提到但是超有用的技巧，由于本人工程师出身，对滑动事件和处理比较敏感，发现了一个程序的小漏洞，当你在如下情况时，往往会打破你预期的规律**  
(1024) (512) (258) (128)  
(4) (8) (16) (32)  
(空） （空） （空） （空）  
(空） （空） （空） （空）  
此时必须要下滑才能继续，但下滑新生成的 2 也许会完全打乱顶部的结构、顺序  
此时你快速下滑，再快速上滑，就会在底部出现两个 2 ，而顶部不会有变化  
原因是两个滑动事件并发接受了，新产生的两个 2 会根据当前的情况选择空白位置
    
    
    
    
### 知乎用户 胖兔子 发表
    
很喜欢这个游戏，可以玩到 8196, 放上我玩的两段录像以供参考：  
[http://video.sina.com.cn/v/b/129302682-1293259722.html](https://link.zhihu.com/?target=http%3A//video.sina.com.cn/v/b/129302682-1293259722.html)  
[http://go2048.com/?replay=5134](https://link.zhihu.com/?target=http%3A//go2048.com/%3Freplay%3D5134)  
（昨天看到了 go2048 这个网站，玩了几把，刷到了比较靠前；今天看到 ilyakor, 也就是目前排第一的那个，他的策略不明觉厉，大家可以观察一下）  
我玩的时候基本策略与

[@chenqin]()

一致，在操作时比较多地使用靠下部的 4\*3 的格子生成 64, 128 和 256 这类方块来给第一行 “进贡”。可以在非危险情况下提高手速。为了拿到高分，可以练一下如何 “在 4\*3 的棋盘内不使用向下的按键，在左上角生成一个 128” (这样就有很大的机会拿到 2048 了); 随着操作的熟练，可以尝试在同样的情形下生成 256 和 512(找到规律之后实际上没有想象中困难，这样玩几次就能玩到 8196 了).
    
    
    
    
### 知乎用户 Sun 发表
    
强答一波.... 最近迷 2048 上课玩睡前玩吃饭玩，终于！！！！  
找到了规律！！！  
先上图



![](https://images.weserv.nl/?url=https%3A//pic4.zhimg.com/v2-ccddeb41a9927c0178949c7dd367d5df_r.jpg%3Fsource%3D1940ef5c)

已经到 65536 了！！还能玩 应该能玩到 2 的 16 方。会有赞吗...
    
    
    
    
### 知乎用户 LeoW 发表
    
看了前面的回答觉得好麻烦... 我也来个

  

其实本质就是两个相同的方格拼在一起变成一个新的（进化的）方格（2 进制数不过是便于人们理解，加法多容易）

玩家大多多玩几次就会发觉如果前几个回合是上下左右任意移动的话后来就会出现四周都有较小的数但移不到一块儿去

于是最好的方法便是把所有新出现的 2 或 4 都放在一个区域内，这样就可以组合成大数与之前的大数相结合，又不能让其他区域内出现小数，所以要尽可能减少移动的方向数

也就是之前大家说到的尽量堆在一个角（方向只用右和上、右和下、左和上、左和下），一个用来消除小数（2 和 4）变大数; 一个用来囤积大数, 到了一定程度让大数相结合再让小数区域内的较大的数填充，周而复始... 加细心一点别不小心死掉的话，通关应该没什么问题了～

差不多就这样:)
    
    
    
    
### 知乎用户  嘉流儿 发表
    
接触了这个游戏有一周了，总结了一些心得：

1.  **把大的数字放在角上（以左上角为例）**
2.  **任何情况都不要往
    
    ![](https://images.weserv.nl/?url=https%3A//www.zhihu.com/equation%3Ftex%3D%255Cdownarrow%2B)
    
    **
3.  **第一排能排满尽量排满**
4.  **数字按蛇形分布**

  

为了形象一些，我就再玩一局吧。方法采用向左上角发展，第一排降序第二排升序的方法：

*   进入到游戏后，你需要做的就是
    
    ![](https://images.weserv.nl/?url=https%3A//www.zhihu.com/equation%3Ftex%3D%255Cuparrow%2B%255Cleftarrow%2B%255Cdownarrow%2B%255Crightarrow%2B%255Cuparrow%2B%255Cleftarrow%2B%255Cdownarrow%2B%255Crightarrow%2B)
    
    乱按，直到左上角的数字达到一个比较大的数，一般是 32，最好不要超过 64  
    

  



![](https://images.weserv.nl/?url=https%3A//pic4.zhimg.com/9c4679c9f2836ef1196e5fb255d1c581_r.jpg%3Fsource%3D1940ef5c)

  

*   接下来就是不断翻倍第一排的数字，使数字全部靠左上角集中。  
    

Tips：在下图这种情况时，一定要把第一排排满，否则你向右的话，你左上角的最大  
数的左边可能会有 2 冒出来。



![](https://images.weserv.nl/?url=https%3A//pic4.zhimg.com/e9539a5b77120cdb40f762dd50677642_r.jpg%3Fsource%3D1940ef5c)

  

*   按照这种策略你的左上角数字会越来越大，也会出现这种必须向右的状况，下面就看你的人品了，如果你的人品太差会再 128 的左边出现一个 2，就会非常棘手，所以尽量避免这种情况

  



![](https://images.weserv.nl/?url=https%3A//pic3.zhimg.com/032b033630d1f29cafcb7be568cbed3b_r.jpg%3Fsource%3D1940ef5c)

  

*   现在已经形成第一排降序，第二排升序的大体形态了

  



![](https://images.weserv.nl/?url=https%3A//pic2.zhimg.com/9a6d64cd319782830bb0a8a827df9789_r.jpg%3Fsource%3D1940ef5c)

  

*   最不想出现的情况出现了，在 256 的左边出现了一个 2，所以我现在的当务之急是除掉这个 2。应该怎么除掉？必须把 2 变成 256，然后 2 个 256 再合并到左上角，虽然很麻烦，但这是必须的也是唯一的方法了

  



![](https://images.weserv.nl/?url=https%3A//pic2.zhimg.com/ab3d6d33c30c873f805a8be8d578a56a_r.jpg%3Fsource%3D1940ef5c)

*   清除了左上角的障碍后，我们继续按前面的原则进行排列

  



![](https://images.weserv.nl/?url=https%3A//pic4.zhimg.com/5019e202ba60ff0f22ac2e98ba36f89e_r.jpg%3Fsource%3D1940ef5c)

  

*   接下来一帆风顺，距离 2048 更近一步了

  



![](https://images.weserv.nl/?url=https%3A//pic1.zhimg.com/573e7d2b3cf738655c5fa4eb1ed28ef3_r.jpg%3Fsource%3D1940ef5c)

  

*   接下来我遇到了一个棘手的问题，因为我必须向下移动了，这对已经成型的第一排是一个毁灭的打击

  



![](https://images.weserv.nl/?url=https%3A//pic2.zhimg.com/dd2d8c0e91937a38aa0020c21a12aac7_r.jpg%3Fsource%3D1940ef5c)

  

*   最后力挽狂澜，拯救住了

  



![](https://images.weserv.nl/?url=https%3A//pic3.zhimg.com/8ae5775567d44cb2d0fb2e83ceb87657_r.jpg%3Fsource%3D1940ef5c)

  

*   如果一切顺利的话，你也会达到 2048

  



![](https://images.weserv.nl/?url=https%3A//pic1.zhimg.com/df1371a0655113ccc4eee1379870fbf5_r.jpg%3Fsource%3D1940ef5c)

*   继续玩，还是用刚才的策略玩到 4096 了

  



![](https://images.weserv.nl/?url=https%3A//pic1.zhimg.com/a8d6bc96916619390abd2cb8852934b1_r.jpg%3Fsource%3D1940ef5c)

*   Game Over！

  



![](https://images.weserv.nl/?url=https%3A//pic2.zhimg.com/0a0acc0d11f03fcea058f214019eac04_r.jpg%3Fsource%3D1940ef5c)

  
**游戏其实多玩，就会总结出一些规律的，这才是游戏的乐趣~**
    
    
    
    
### 知乎用户  玦兮 发表
    
受同学的鼓励，前来进行首答，不喜勿喷。  
两年前玩 2048 发现两条规律，运用下答主玩到了 8192，可能与上面的回答有重复。  



![](https://images.weserv.nl/?url=https%3A//pic1.zhimg.com/v2-7355ad394d22d378232445c2428e41d5_r.jpg%3Fsource%3D1940ef5c)

第一条规律：  
2048 就那么大的屏，16 格，走一步出一个方块，那么如果你一步把两个数字合并成一个数字，因为又会冒出新的数字，所以总的数字总数不会变化。  
然而这个游戏又是全部 16 个数字满格且不能动算输，所以数字越少越不容易输。  
真正减少屏幕上数字个数的，是一步能造成两组数字或者更多数字的结合。  
比如这样:  
（前两行空着）  
8 4 4 2  
8 4 4 2  
往下一步，屏幕少四个数字，这样的步数多了不容易输。

第二条规律：  
我习惯把大数字放在左下角，那么尽量保证只有向下和向左两个动作。其他角落可以类推。  
然后参考一个阵型  
类似这样:  
（前两行空）  
2 2  
32 16 8 4  
大概意思是要尽量做到数字的有序排列，如果达到两倍的数字的有序排列，那么再来一个 4 或者 2 可以一下子连续走好几步。

希望大家游戏愉快~
    
    
    
    
### 知乎用户  麟 lin 发表
    
突然明白 2048 叠加本质的来答一波，我当年也是被角落最大数，然后依次排开，

即底层 512 | 256 | 128 | 64 的方式排列。

但大家这样排序的时候会遇到一个问题，一不小心就会清场。

变成 1024 | 2 | 4 | 2 | 这样就很容易导致不得不向上移动导致最大数离开边角。

其实正确玩法是摆成

x | x | x | x

32 | 4 | 16 | 8

64 | 16 | 32 | 128

512 | 128 | 256 | 64

这样的排列顺序。保证不会在组数的过程中不小心将数合成大数从而打乱顺序。

这样排列有什么好处呢？2 只会在最上一排刷新，你随时可以把最右边的 8 组成 16，16 变 32，然后继续组数。

**这个游戏的本质是压缩不稳定因素，即生成 2 的地方，只可以单方向移动。**

其次也是最重要的，

不要清场

不要清场

不要清场

像热评一样组成这样也没问题

4 | 8 | 16 | 32

512 | 256 | 128 | 64

也不要觉得组不成这样就赢不了了。能组成这样的情况太极端了。

**但千万不要把这些数一口气变成**

x | x | x | x

1024 | x | x | x

这样
    
    
    
    
### 知乎用户  fangazio 发表
    
控制台输入：  
GameManager.prototype.addRandomTile = function () {  
if (this.grid.cellsAvailable()) {  
var value = 1024;  
var tile = new Tile(this.grid.randomAvailableCell(), value);

this.grid.insertTile(tile);  
}  
};  
既然我不像适应它的规则，我就改变他的规则吧 233333333
    
    
    
    
### 知乎用户 WindyWay 发表
    
原理就是: 保证形成一个递增 2^n 次方链, 所以要保证这个链不断裂需要保持大数边界的稳定. 但实际上你能不能完成十分依靠运气. 我写了一个极难 2048. 谁能玩到 512 请联系我

[极难 2048](https://link.zhihu.com/?target=http%3A//weidwonder.github.io/Hard-Game-2048/)

不会搭配颜色, 有点太丑了, 不妨碍玩



![](https://images.weserv.nl/?url=https%3A//pic4.zhimg.com/v2-91ce1a40567ddeccf71ee15fb5ef631c_r.jpg%3Fsource%3D1940ef5c)
    
    
    
    
### 知乎用户  小王子 发表
    
把最大的数字放在一个角落，不要去改变他的位置，他的上面是第二大的，再上面是第三大，然后第四大，之后第四大的旁边是第五，依次类推，有一个小图，画的不整齐，大家凑活一下



![](https://images.weserv.nl/?url=https%3A//pic4.zhimg.com/v2-55da1b3c92eb6085ede0641b10909004_r.jpg%3Fsource%3D1940ef5c)
    
    
    
    
### 知乎用户  许三观家的一乐 发表
    
分割线……

经评论区，发现了问题，我这个方法是针对把最大的数字放在最下面一行的情况。

有人喜欢把最大的数字放在最上面一行，所以她应该是永远不往下滑。

准确的方法是：

你把最大的数字放在最上一行，就永远别往下滑；

你把最大的数字放在最下一行，就永远别往下滑；

你把最大的数字放在最右一行，就永远别往左滑；

你把最大的数字放在最 左一行，就永远别往右滑。

哈哈！！

原答案：

不到要跪了，永远不要往上滑！！

以前我也是菜鸟一个，后来看到很多攻略。

其实都是浮云，还得自己摸索。

然，有个攻略里面一句 “永远不要往上滑！” 就一直左，右，下方向滑动！除非要死了，不往上滑就要跪了，再去往上去滑动。

记住这一条，玩个一段时间，2048 就很简单了。

至于 double2048，要看一丢丢运气的！



![](https://images.weserv.nl/?url=https%3A//pic4.zhimg.com/v2-15d20caba5a87deb4982ebae2e0cce46_r.jpg%3Fsource%3D1940ef5c)



![](https://images.weserv.nl/?url=https%3A//pic3.zhimg.com/v2-4b18d6e2cc7681e0722a4fe0805e88d9_r.jpg%3Fsource%3D1940ef5c)



![](https://images.weserv.nl/?url=https%3A//pic1.zhimg.com/v2-feeb6fefacb4ea10a7654d98ffc634b8_r.jpg%3Fsource%3D1940ef5c)

记住了，只往 “下↘右↘左↘” 这三个方向滑动！！！
    
    
    
    
### 知乎用户 法式青春散文诗 发表
    
按照顺序摆放，从大到小方便后面合体，最大的放在角落，按照这规律慢慢积累，如图…
    
    
    
    
### 知乎用户 hrhrng 发表
    
有个 “升级版” 叫 16384，规则一致，8\*8 格，写了个脚本跑了一天还没 game over



![](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='160' height='160'></svg>)
    
    
    

